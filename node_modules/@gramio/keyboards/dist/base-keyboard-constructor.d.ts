type ButtonsIterator<T> = (options: {
    button: T;
    index: number;
    row: T[];
    rowIndex: number;
}) => boolean;
type CreateButtonIterator<T> = (options: {
    index: number;
    rowIndex: number;
}) => T;
/** Base-class for construct keyboard with useful helpers */
export declare class BaseKeyboardConstructor<T> {
    protected rows: T[][];
    protected currentRow: T[];
    private wrapOptions;
    protected get keyboard(): T[][];
    /**
     * Adds a `line break`. Call this method to make sure that the next added buttons will be on a new row.
     * @example
     * ```ts
     * new InlineKeyboard()
     *     .text("first row", "payload")
     *     .row()
     *     .text("second row", "payload");
     * ```
     */
    row(): this;
    /**
     * Allows you to limit the number of columns in the keyboard.
     * @example
     * ```ts
     * new InlineKeyboard()
     *     .columns(1)
     *     .text("first row", "payload")
     *     .text("second row", "payload");
     *     .text("third row", "payload");
     * ```
     */
    columns(length?: number): this;
    /**
     * A custom handler that controls row wrapping.
     * @example
     * ```ts
     * new InlineKeyboard()
     *     .wrap(({ button }) => button.callback_data === "2")
     *     .text("first row", "1")
     *     .text("first row", "1");
     *     .text("second row", "2");
     * ```
     */
    wrap(fn?: ButtonsIterator<T>): this;
    /**
     * A handler that helps filter keyboard buttons
     * @example
     * ```ts
     * new InlineKeyboard()
     *     .filter(({ button }) => button.callback_data !== "hidden")
     *     .text("button", "pass")
     *     .text("button", "hidden")
     *     .text("button", "pass");
     * ```
     */
    filter(fn?: ButtonsIterator<T>): this;
    /**
     * An array with the number of columns per row. Allows you to set a "template"
     * @example
     * ```ts
     * new InlineKeyboard()
     *     .pattern([1, 3, 2])
     *     .text("1", "payload")
     *     .text("2", "payload")
     *     .text("2", "payload")
     *     .text("2", "payload")
     *     .text("3", "payload")
     *     .text("3", "payload");
     * ```
     */
    pattern(pattern?: number[]): this;
    /**
     * Allows you to add multiple buttons in raw format.
     * @example
     * ```ts
     * const labels = ["some", "buttons"];
     *
     * new InlineKeyboard()
     *     .add({ text: "raw button", callback_data: "payload" })
     *     .add(InlineKeyboard.text("raw button by InlineKeyboard.text", "payload"))
     *     .add(...labels.map((x) => InlineKeyboard.text(x, `${x}payload`)));
     * ```
     */
    add(...buttons: T[]): this;
    /**
     * Allows you to dynamically substitute buttons depending on something
     * @example
     * ```ts
     * const labels = ["some", "buttons"];
     * const isAdmin = true;
     *
     * new InlineKeyboard()
     *     .addIf(1 === 2, { text: "raw button", callback_data: "payload" })
     *     .addIf(
     *         isAdmin,
     *         InlineKeyboard.text("raw button by InlineKeyboard.text", "payload")
     *     )
     *     .addIf(
     *         ({ index, rowIndex }) => rowIndex === index,
     *         ...labels.map((x) => InlineKeyboard.text(x, `${x}payload`))
     *     );
     * ```
     */
    addIf(condition: ((options: {
        rowIndex: number;
        index: number;
    }) => boolean) | boolean, ...buttons: T[]): this;
    /**
     * Allows you to create a button matrix.
     * @example
     * ```ts
     * import { randomInt } from "node:crypto";
     *
     * const bomb = [randomInt(0, 9), randomInt(0, 9)] as const;
     *
     * new InlineKeyboard().matrix(10, 10, ({ rowIndex, index }) =>
     *    InlineKeyboard.text(
     *        rowIndex === bomb[0] && index === bomb[1] ? "ðŸ’£" : "ã…¤",
     *        "payload"
     *    )
     *);
     * ```
     */
    matrix(rows: number, columns: number, fn: CreateButtonIterator<T>): this;
}
export {};
