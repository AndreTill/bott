"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptedPassportElement = void 0;
const tslib_1 = require("tslib");
const inspectable_1 = require("inspectable");
const utils_1 = require("../utils");
const passport_file_1 = require("./passport-file");
/**
 * Contains information about documents or other Telegram Passport elements
 * shared with the bot by the user.
 */
let EncryptedPassportElement = (() => {
    let _classDecorators = [(0, inspectable_1.Inspectable)()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _instanceExtraInitializers = [];
    let _get_type_decorators;
    let _get_data_decorators;
    let _get_phoneNumber_decorators;
    let _get_email_decorators;
    let _get_files_decorators;
    let _get_frontSide_decorators;
    let _get_reverseSide_decorators;
    let _get_selfie_decorators;
    let _get_translation_decorators;
    let _get_hash_decorators;
    var EncryptedPassportElement = class {
        static { _classThis = this; }
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _get_type_decorators = [(0, inspectable_1.Inspect)()];
            _get_data_decorators = [(0, inspectable_1.Inspect)()];
            _get_phoneNumber_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_email_decorators = [(0, inspectable_1.Inspect)()];
            _get_files_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_frontSide_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_reverseSide_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_selfie_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_translation_decorators = [(0, inspectable_1.Inspect)()];
            _get_hash_decorators = [(0, inspectable_1.Inspect)()];
            tslib_1.__esDecorate(this, null, _get_type_decorators, { kind: "getter", name: "type", static: false, private: false, access: { has: obj => "type" in obj, get: obj => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_data_decorators, { kind: "getter", name: "data", static: false, private: false, access: { has: obj => "data" in obj, get: obj => obj.data }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_phoneNumber_decorators, { kind: "getter", name: "phoneNumber", static: false, private: false, access: { has: obj => "phoneNumber" in obj, get: obj => obj.phoneNumber }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_email_decorators, { kind: "getter", name: "email", static: false, private: false, access: { has: obj => "email" in obj, get: obj => obj.email }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_files_decorators, { kind: "getter", name: "files", static: false, private: false, access: { has: obj => "files" in obj, get: obj => obj.files }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_frontSide_decorators, { kind: "getter", name: "frontSide", static: false, private: false, access: { has: obj => "frontSide" in obj, get: obj => obj.frontSide }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_reverseSide_decorators, { kind: "getter", name: "reverseSide", static: false, private: false, access: { has: obj => "reverseSide" in obj, get: obj => obj.reverseSide }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_selfie_decorators, { kind: "getter", name: "selfie", static: false, private: false, access: { has: obj => "selfie" in obj, get: obj => obj.selfie }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_translation_decorators, { kind: "getter", name: "translation", static: false, private: false, access: { has: obj => "translation" in obj, get: obj => obj.translation }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_hash_decorators, { kind: "getter", name: "hash", static: false, private: false, access: { has: obj => "hash" in obj, get: obj => obj.hash }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            EncryptedPassportElement = _classThis = _classDescriptor.value;
            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            tslib_1.__runInitializers(_classThis, _classExtraInitializers);
        }
        payload = tslib_1.__runInitializers(this, _instanceExtraInitializers);
        constructor(payload) {
            this.payload = payload;
        }
        /** [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag) */
        get [Symbol.toStringTag]() {
            return this.constructor.name;
        }
        /**
         * Element type. One of `personal_details`, `passport`, `driver_license`,
         * `identity_card`, `internal_passport`, `address`, `utility_bill`,
         * `bank_statement`, `rental_agreement`, `passport_registration`,
         * `temporary_registration`, `phone_number`, `email`.
         */
        get type() {
            return this.payload.type;
        }
        /**
         * Base64-encoded encrypted Telegram Passport element data provided by th
         * user, available for `personal_details`, `passport`, `driver_license`,
         * `identity_card`, `internal_passport` and `address` types.
         * Can be decrypted and verified using the accompanying
         * `EncryptedCredentials`.
         */
        get data() {
            return this.payload.data;
        }
        /** User's verified phone number, available only for `phone_number` type */
        get phoneNumber() {
            return this.payload.phone_number;
        }
        /** User's verified email address, available only for `email` type */
        get email() {
            return this.payload.email;
        }
        /**
         * Array of encrypted files with documents provided by the user, available
         * for `utility_bill`, `bank_statement`, `rental_agreement`,
         * `passport_registration` and `temporary_registration` types. Files can be
         * decrypted and verified using the accompanying `EncryptedCredentials`.
         */
        get files() {
            const { files } = this.payload;
            if (!files)
                return undefined;
            return files.map((file) => new passport_file_1.PassportFile(file));
        }
        /**
         * Encrypted file with the front side of the document, provided by the user.
         * Available for `passport`, `driver_license`, `identity_card` and
         * `internal_passport`. The file can be decrypted and verified using the
         * accompanying `EncryptedCredentials`.
         */
        get frontSide() {
            const { front_side } = this.payload;
            if (!front_side)
                return undefined;
            return new passport_file_1.PassportFile(front_side);
        }
        /**
         * Encrypted file with the reverse side of the document, provided by the
         * user. Available for `driver_license` and `identity_card`. The file can be
         * decrypted and verified using the accompanying `EncryptedCredentials`.
         */
        get reverseSide() {
            const { reverse_side } = this.payload;
            if (!reverse_side)
                return undefined;
            return new passport_file_1.PassportFile(reverse_side);
        }
        /**
         * Encrypted file with the selfie of the user holding a document, provided by
         * the user; available for `passport`, `driver_license`, `identity_card` and
         * `internal_passport`. The file can be decrypted and verified using the
         * accompanying `EncryptedCredentials`.
         */
        get selfie() {
            const { selfie } = this.payload;
            if (!selfie)
                return undefined;
            return new passport_file_1.PassportFile(selfie);
        }
        /**
         * Array of encrypted files with translated versions of documents provided by
         * the user. Available if requested for `passport`, `driver_license`,
         * `identity_card`, `internal_passport`, `utility_bill`, `bank_statement`,
         * `rental_agreement`, `passport_registration` and `temporary_registration`
         * types. Files can be decrypted and verified using the accompanying
         * `EncryptedCredentials`.
         */
        get translation() {
            const { translation } = this.payload;
            if (!translation)
                return undefined;
            return translation.map((element) => new passport_file_1.PassportFile(element));
        }
        /**
         * Base64-encoded element hash for using in `PassportElementErrorUnspecified`
         */
        get hash() {
            return this.payload.hash;
        }
    };
    return EncryptedPassportElement = _classThis;
})();
exports.EncryptedPassportElement = EncryptedPassportElement;
(0, utils_1.memoizeGetters)(EncryptedPassportElement, [
    "frontSide",
    "reverseSide",
    "selfie",
]);
