"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineKeyboardButton = void 0;
const tslib_1 = require("tslib");
const inspectable_1 = require("inspectable");
const utils_1 = require("../utils");
const callback_game_1 = require("./callback-game");
const login_url_1 = require("./login-url");
/** This object represents one button of an inline keyboard. You must use exactly one of the optional fields. */
let InlineKeyboardButton = (() => {
    let _classDecorators = [(0, inspectable_1.Inspectable)()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _instanceExtraInitializers = [];
    let _get_text_decorators;
    let _get_url_decorators;
    let _get_loginUrl_decorators;
    let _get_callbackData_decorators;
    let _get_switchInlineQuery_decorators;
    let _get_switchInlineQueryCurrentChat_decorators;
    let _get_callbackGame_decorators;
    let _get_pay_decorators;
    var InlineKeyboardButton = class {
        static { _classThis = this; }
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _get_text_decorators = [(0, inspectable_1.Inspect)()];
            _get_url_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_loginUrl_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_callbackData_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_switchInlineQuery_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_switchInlineQueryCurrentChat_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_callbackGame_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_pay_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            tslib_1.__esDecorate(this, null, _get_text_decorators, { kind: "getter", name: "text", static: false, private: false, access: { has: obj => "text" in obj, get: obj => obj.text }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_url_decorators, { kind: "getter", name: "url", static: false, private: false, access: { has: obj => "url" in obj, get: obj => obj.url }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_loginUrl_decorators, { kind: "getter", name: "loginUrl", static: false, private: false, access: { has: obj => "loginUrl" in obj, get: obj => obj.loginUrl }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_callbackData_decorators, { kind: "getter", name: "callbackData", static: false, private: false, access: { has: obj => "callbackData" in obj, get: obj => obj.callbackData }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_switchInlineQuery_decorators, { kind: "getter", name: "switchInlineQuery", static: false, private: false, access: { has: obj => "switchInlineQuery" in obj, get: obj => obj.switchInlineQuery }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_switchInlineQueryCurrentChat_decorators, { kind: "getter", name: "switchInlineQueryCurrentChat", static: false, private: false, access: { has: obj => "switchInlineQueryCurrentChat" in obj, get: obj => obj.switchInlineQueryCurrentChat }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_callbackGame_decorators, { kind: "getter", name: "callbackGame", static: false, private: false, access: { has: obj => "callbackGame" in obj, get: obj => obj.callbackGame }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_pay_decorators, { kind: "getter", name: "pay", static: false, private: false, access: { has: obj => "pay" in obj, get: obj => obj.pay }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            InlineKeyboardButton = _classThis = _classDescriptor.value;
            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            tslib_1.__runInitializers(_classThis, _classExtraInitializers);
        }
        payload = tslib_1.__runInitializers(this, _instanceExtraInitializers);
        constructor(payload) {
            this.payload = payload;
        }
        /** [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag) */
        get [Symbol.toStringTag]() {
            return this.constructor.name;
        }
        /** Label text on the button */
        get text() {
            return this.payload.text;
        }
        /** HTTP or tg:// url to be opened when button is pressed */
        get url() {
            return this.payload.url;
        }
        /**
         * An HTTP URL used to automatically authorize the user.
         * Can be used as a replacement for the Telegram Login Widget.
         */
        get loginUrl() {
            const { login_url } = this.payload;
            if (!login_url)
                return undefined;
            return new login_url_1.LoginUrl(login_url);
        }
        /**
         * Data to be sent in a callback query to the bot when button is pressed,
         * 1-64 bytes
         */
        get callbackData() {
            return this.payload.callback_data;
        }
        /**
         * If set, pressing the button will prompt the user to select one of their
         * chats, open that chat and insert the bot's username and the specified
         * inline query in the input field. Can be empty, in which case just the
         * bot's username will be inserted.
         *
         * **Note**: This offers an easy way for users to start using your bot in
         * inline mode when they are currently in a private chat with it. Especially
         * useful when combined with `switch_pm…` actions – in this case the user will
         * be automatically returned to the chat they switched from, skipping the
         * chat selection screen.
         */
        get switchInlineQuery() {
            return this.payload.switch_inline_query;
        }
        /**
         * If set, pressing the button will insert the bot's username and the
         * specified inline query in the current chat's input field. Can be empty, in
         * which case only the bot's username will be inserted.
         *
         * This offers a quick way for the user to open your bot in inline mode in
         * the same chat – good for selecting something from multiple options.
         */
        get switchInlineQueryCurrentChat() {
            return this.payload.switch_inline_query_current_chat;
        }
        /**
         * Description of the game that will be launched when the user presses the
         * button.
         *
         * **NOTE**: This type of button **must** always be the first button in the
         * first row.
         */
        get callbackGame() {
            const { callback_game } = this.payload;
            if (!callback_game)
                return undefined;
            return new callback_game_1.CallbackGame(callback_game);
        }
        /**
         * Specify `true`, to send a Pay button.
         *
         * **NOTE**: This type of button **must** always be the first button in the first row.
         */
        get pay() {
            return this.payload.pay;
        }
    };
    return InlineKeyboardButton = _classThis;
})();
exports.InlineKeyboardButton = InlineKeyboardButton;
(0, utils_1.memoizeGetters)(InlineKeyboardButton, ["loginUrl", "callbackGame"]);
