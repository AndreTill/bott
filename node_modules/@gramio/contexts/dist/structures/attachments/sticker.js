"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StickerAttachment = void 0;
const tslib_1 = require("tslib");
const inspectable_1 = require("inspectable");
const file_1 = require("../file");
const mask_position_1 = require("../mask-position");
const photo_size_1 = require("../photo-size");
const utils_1 = require("../../utils");
const file_attachment_1 = require("./file-attachment");
/** This object represents a sticker. */
// TODO: extended: ['fileId', 'fileUniqueId']
let StickerAttachment = (() => {
    let _classDecorators = [(0, inspectable_1.Inspectable)()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _classSuper = file_attachment_1.FileAttachment;
    let _instanceExtraInitializers = [];
    let _get_type_decorators;
    let _get_width_decorators;
    let _get_height_decorators;
    let _isAnimated_decorators;
    let _isVideo_decorators;
    let _get_thumbnail_decorators;
    let _get_emoji_decorators;
    let _get_setName_decorators;
    let _get_premiumAnimation_decorators;
    let _get_maskPosition_decorators;
    let _get_customEmojiId_decorators;
    let _get_needs_repainting_decorators;
    let _get_fileSize_decorators;
    var StickerAttachment = class extends _classSuper {
        static { _classThis = this; }
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _get_type_decorators = [(0, inspectable_1.Inspect)()];
            _get_width_decorators = [(0, inspectable_1.Inspect)()];
            _get_height_decorators = [(0, inspectable_1.Inspect)()];
            _isAnimated_decorators = [(0, inspectable_1.Inspect)({ compute: true })];
            _isVideo_decorators = [(0, inspectable_1.Inspect)({ compute: true })];
            _get_thumbnail_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_emoji_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_setName_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_premiumAnimation_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_maskPosition_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_customEmojiId_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_needs_repainting_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            _get_fileSize_decorators = [(0, inspectable_1.Inspect)({ nullable: false })];
            tslib_1.__esDecorate(this, null, _get_type_decorators, { kind: "getter", name: "type", static: false, private: false, access: { has: obj => "type" in obj, get: obj => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_width_decorators, { kind: "getter", name: "width", static: false, private: false, access: { has: obj => "width" in obj, get: obj => obj.width }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_height_decorators, { kind: "getter", name: "height", static: false, private: false, access: { has: obj => "height" in obj, get: obj => obj.height }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _isAnimated_decorators, { kind: "method", name: "isAnimated", static: false, private: false, access: { has: obj => "isAnimated" in obj, get: obj => obj.isAnimated }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _isVideo_decorators, { kind: "method", name: "isVideo", static: false, private: false, access: { has: obj => "isVideo" in obj, get: obj => obj.isVideo }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_thumbnail_decorators, { kind: "getter", name: "thumbnail", static: false, private: false, access: { has: obj => "thumbnail" in obj, get: obj => obj.thumbnail }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_emoji_decorators, { kind: "getter", name: "emoji", static: false, private: false, access: { has: obj => "emoji" in obj, get: obj => obj.emoji }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_setName_decorators, { kind: "getter", name: "setName", static: false, private: false, access: { has: obj => "setName" in obj, get: obj => obj.setName }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_premiumAnimation_decorators, { kind: "getter", name: "premiumAnimation", static: false, private: false, access: { has: obj => "premiumAnimation" in obj, get: obj => obj.premiumAnimation }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_maskPosition_decorators, { kind: "getter", name: "maskPosition", static: false, private: false, access: { has: obj => "maskPosition" in obj, get: obj => obj.maskPosition }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_customEmojiId_decorators, { kind: "getter", name: "customEmojiId", static: false, private: false, access: { has: obj => "customEmojiId" in obj, get: obj => obj.customEmojiId }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_needs_repainting_decorators, { kind: "getter", name: "needs_repainting", static: false, private: false, access: { has: obj => "needs_repainting" in obj, get: obj => obj.needs_repainting }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(this, null, _get_fileSize_decorators, { kind: "getter", name: "fileSize", static: false, private: false, access: { has: obj => "fileSize" in obj, get: obj => obj.fileSize }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            StickerAttachment = _classThis = _classDescriptor.value;
            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            tslib_1.__runInitializers(_classThis, _classExtraInitializers);
        }
        attachmentType = (tslib_1.__runInitializers(this, _instanceExtraInitializers), "sticker");
        /**
         * Type of the sticker, currently one of `regular`, `mask`, `custom_emoji`.
         *
         * The type of the sticker is independent from its format, which is determined by the fields `is_animated` and `is_video`.
         */
        get type() {
            return this.payload.type;
        }
        /** Sticker width */
        get width() {
            return this.payload.width;
        }
        /** Sticker height */
        get height() {
            return this.payload.height;
        }
        /** `true`, if the sticker is animated */
        isAnimated() {
            return this.payload.is_animated;
        }
        /** `true`, if the sticker is a video sticker */
        isVideo() {
            return this.payload.is_video;
        }
        /** Sticker thumbnail in the .WEBP or .JPG format */
        get thumbnail() {
            const { thumbnail } = this.payload;
            if (!thumbnail)
                return undefined;
            return new photo_size_1.PhotoSize(thumbnail);
        }
        /** Emoji associated with the sticker */
        get emoji() {
            return this.payload.emoji;
        }
        /** Name of the sticker set to which the sticker belongs */
        get setName() {
            return this.payload.set_name;
        }
        /** Is this sticker a premium one? */
        isPremium() {
            return this.premiumAnimation !== undefined;
        }
        /** Premium animation for the sticker, if the sticker is premium */
        get premiumAnimation() {
            const { premium_animation } = this.payload;
            if (!premium_animation)
                return undefined;
            return new file_1.File(premium_animation);
        }
        /** For mask stickers, the position where the mask should be placed */
        get maskPosition() {
            const { mask_position } = this.payload;
            if (!mask_position)
                return undefined;
            return new mask_position_1.MaskPosition(mask_position);
        }
        /** For custom emoji stickers, unique identifier of the custom emoji */
        get customEmojiId() {
            return this.payload.custom_emoji_id;
        }
        /** `true`, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places */
        get needs_repainting() {
            return this.payload.needs_repainting;
        }
        /** File size */
        get fileSize() {
            return this.payload.file_size;
        }
    };
    return StickerAttachment = _classThis;
})();
exports.StickerAttachment = StickerAttachment;
(0, utils_1.memoizeGetters)(StickerAttachment, [
    "thumbnail",
    "premiumAnimation",
    "maskPosition",
]);
