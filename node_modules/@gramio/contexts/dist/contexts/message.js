"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageContext = void 0;
const tslib_1 = require("tslib");
const inspectable_1 = require("inspectable");
const index_1 = require("../structures/attachments/index");
// import { MediaGroup } from "../media-group";
const index_2 = require("../structures/index");
const utils_1 = require("../utils");
const utils_2 = require("../utils");
const paid_media_info_1 = require("../structures/paid-media-info");
const context_1 = require("./context");
const index_3 = require("./mixins/index");
/** Called when `message` event occurs */
let MessageContext = (() => {
    let _classSuper = context_1.Context;
    let _instanceExtraInitializers = [];
    let _get_paidMedia_decorators;
    return class MessageContext extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _get_paidMedia_decorators = [(0, inspectable_1.Inspect)()];
            tslib_1.__esDecorate(this, null, _get_paidMedia_decorators, { kind: "getter", name: "paidMedia", static: false, private: false, access: { has: obj => "paidMedia" in obj, get: obj => obj.paidMedia }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        /** The raw data that is used for this Context */
        payload = tslib_1.__runInitializers(this, _instanceExtraInitializers);
        #text;
        #caption;
        // mediaGroup?: MediaGroup;
        constructor(options) {
            super({
                bot: options.bot,
                updateType: options.type ?? "message",
                updateId: options.updateId,
                update: options.update,
            });
            this.payload = options.payload;
            this.#text = this.payload.text;
            this.#caption = this.payload.caption;
        }
        /**
         * For text messages, the actual UTF-8 text of the message, 0-4096 characters
         */
        get text() {
            return this.#text;
        }
        set text(text) {
            this.#text = text;
        }
        /** Checks if the message has `text` property */
        hasText() {
            return this.text !== undefined;
        }
        /**
         * Caption for the animation, audio, document, photo, video or voice,
         * 0-1024 characters
         */
        get caption() {
            return this.#caption;
        }
        set caption(caption) {
            this.#caption = caption;
        }
        /** Checks if the message has `caption` property */
        hasCaption() {
            return this.caption !== undefined;
        }
        /** Checks if the message has `dice` property */
        hasDice() {
            return this.dice !== undefined;
        }
        /** Value after the `/start` command */
        get rawStartPayload() {
            if (!this.hasText())
                return undefined;
            const text = this.text;
            if (!text.startsWith("/start") || text === "/start")
                return undefined;
            return text.split(" ")[1];
        }
        /** Parsed value after the `/start` command */
        get startPayload() {
            let payload = this.rawStartPayload;
            if (payload === undefined)
                return undefined;
            if (!Number.isNaN(+payload)) {
                payload = Number.parseInt(payload, 10);
            }
            else if ((0, utils_1.isParsable)(payload)) {
                payload = JSON.parse(payload);
            }
            return payload;
        }
        /** Does this message have start payload? */
        hasStartPayload() {
            return this.startPayload !== undefined;
        }
        /** Checks if the message has `author_signature` property */
        hasAuthorSignature() {
            return this.authorSignature !== undefined;
        }
        /** Checks if there are any entities (with specified type) */
        hasEntities(type) {
            if (this.entities === undefined) {
                return false;
            }
            if (type === undefined) {
                return this.entities.length !== 0;
            }
            return this.entities.some((entity) => entity.type === type);
        }
        /** Checks if there are any caption entities (with specified type) */
        hasCaptionEntities(type) {
            if (this.captionEntities === undefined) {
                return false;
            }
            if (type === undefined) {
                return this.captionEntities.length !== 0;
            }
            return this.captionEntities.some((entity) => entity.type === type);
        }
        get paidMedia() {
            return this.payload.paid_media
                ? new paid_media_info_1.PaidMediaInfo(this.payload.paid_media)
                : undefined;
        }
        // /** Checks whether current message contains a media group (`mergeMediaEvents` must be on) */
        // isMediaGroup(): this is Require<this, "mediaGroupId" | "mediaGroup"> {
        // 	return this.mediaGroupId !== undefined;
        // }
        /** Message attachment */
        get attachment() {
            if (this.photo) {
                return new index_1.PhotoAttachment(this.photo);
            }
            if (this.contact) {
                return new index_1.ContactAttachment(this.payload.contact);
            }
            if (this.poll) {
                return new index_1.PollAttachment(this.payload.poll);
            }
            if (this.venue) {
                return new index_1.VenueAttachment(this.payload.venue);
            }
            if (this.location) {
                return new index_1.LocationAttachment(this.payload.location);
            }
            return (this.sticker ??
                this.story ??
                this.animation ??
                this.audio ??
                this.document ??
                this.video ??
                this.videoNote ??
                this.voice);
        }
        /** Does this message have an attachment with a specific type `type`? */
        hasAttachmentType(type) {
            return this.attachment?.attachmentType === type;
        }
        /** Does this message even have an attachment? */
        hasAttachment() {
            return this.attachment !== undefined;
        }
        /** Is this message a giveaway */
        isGiveaway() {
            return this.giveaway !== undefined;
        }
        /** Is this message an event? */
        isEvent() {
            return utils_2.EVENTS.some((event) => this[event[0]] !== undefined);
        }
        /** Event type */
        get eventType() {
            if (!this.isEvent()) {
                return undefined;
            }
            const value = utils_2.EVENTS.find((event) => {
                const tValue = this[event[0]];
                if (Array.isArray(tValue)) {
                    return tValue.length !== 0;
                }
                return tValue !== undefined;
            });
            if (value === undefined)
                return undefined;
            return value[1];
        }
        /** Is this message a service one? */
        isServiceMessage() {
            return utils_2.SERVICE_MESSAGE_EVENTS.some((event) => this.payload[event] !== undefined);
        }
        /** Is this message in topic */
        isTopicMessage() {
            return !!this.payload.is_topic_message;
        }
        /** Does this message have a forward origin? */
        hasForwardOrigin() {
            return this.forwardOrigin !== undefined;
        }
        /** Does this message have a quote? */
        hasQuote() {
            return this.quote !== undefined;
        }
        /** Does this message have link preview options? */
        hasLinkPreviewOptions() {
            return this.linkPreviewOptions !== undefined;
        }
        /** Does this message have external reply info? */
        hasReplyInfo() {
            return this.externalReply !== undefined;
        }
        /** Does this message have reply message? */
        hasReplyMessage() {
            return this.replyMessage !== undefined;
        }
        /** Checks if the sent message has `via_bot` property */
        hasViaBot() {
            return this.viaBot !== undefined;
        }
        /** @deprecated use `hasAttachmentType(type)` and `hasAttachment` instead */
        hasAttachments(type) {
            if (type === undefined) {
                return this.hasAttachment();
            }
            return this.hasAttachmentType(type);
        }
    };
})();
exports.MessageContext = MessageContext;
(0, utils_1.applyMixins)(MessageContext, [
    index_2.Message,
    index_3.TargetMixin,
    index_3.SendMixin,
    index_3.ChatActionMixin,
    index_3.NodeMixin,
    index_3.DownloadMixin,
    index_3.ChatInviteControlMixin,
    index_3.ChatControlMixin,
    index_3.ChatSenderControlMixin,
    index_3.ChatMemberControlMixin,
    index_3.PinsMixin,
    index_3.CloneMixin,
]);
(0, utils_1.memoizeGetters)(MessageContext, ["attachment"]);
(0, inspectable_1.inspectable)(MessageContext, {
    serialize: (context) => {
        const payload = {
            id: context.id,
            from: context.from,
            createdAt: context.createdAt,
            chat: context.chat,
            senderBoostCount: context.senderBoostCount,
            replyMessage: context.replyMessage,
            viaBot: context.viaBot,
            updatedAt: context.updatedAt,
            authorSignature: context.authorSignature,
            text: context.text,
            entities: context.entities,
            captionEntities: context.captionEntities,
            dice: context.dice,
            caption: context.caption,
            contact: context.contact,
            location: context.location,
            venue: context.venue,
            poll: context.poll,
            replyMarkup: context.replyMarkup,
        };
        // if (context.mediaGroup !== undefined) {
        // 	payload.mediaGroup = context.mediaGroup;
        // } else {
        // 	payload.mediaGroupId = context.mediaGroupId;
        // 	payload.attachment = context.attachment;
        // }
        return (0, utils_1.filterPayload)(payload);
    },
});
