'use strict';

var storage = require('@gramio/storage');
var gramio = require('gramio');
var node_crypto = require('node:crypto');

async function getFileHash(file) {
  file = await file;
  return node_crypto.createHash("md5").update(file.name + file.size + await file.text()).digest("hex");
}
function isFile(file) {
  if (!file || typeof file !== "object") return false;
  return file instanceof File || file instanceof Promise;
}
const MEDIA_CACHED = Symbol("MEDIA_CACHED");

const MEDIA_HELPERS = {
  sendPhoto: [
    async (params, storage) => {
      if (isFile(params.photo)) {
        const file = await params.photo;
        const hash = await getFileHash(file);
        const fileId = await storage.get(hash);
        if (fileId) {
          params[MEDIA_CACHED] = file;
          params.photo = fileId;
        }
      }
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
      if (response.photo) {
        const hash = await getFileHash(params.photo);
        await storage.set(hash, response.photo.at(-1).file_id);
      }
    }
  ],
  sendAudio: [
    async (params, storage) => {
      if (isFile(params.audio)) {
        const file = await params.audio;
        const hash = await getFileHash(file);
        const fileId = await storage.get(hash);
        if (fileId) {
          params[MEDIA_CACHED] = file;
          params.audio = fileId;
        }
      }
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
      if (response.audio) {
        const hash = await getFileHash(params.audio);
        await storage.set(hash, response.audio.file_id);
      }
    }
  ],
  sendDocument: [
    async (params, storage) => {
      if (isFile(params.document)) {
        const file = await params.document;
        const hash = await getFileHash(file);
        const fileId = await storage.get(hash);
        if (fileId) {
          params[MEDIA_CACHED] = file;
          params.document = fileId;
        }
      }
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
      if (response.document) {
        const hash = await getFileHash(params.document);
        await storage.set(hash, response.document.file_id);
      }
    }
  ],
  sendVideo: [
    async (params, storage) => {
      if (isFile(params.video)) {
        const file = await params.video;
        const hash = await getFileHash(file);
        const fileId = await storage.get(hash);
        if (fileId) {
          params[MEDIA_CACHED] = file;
          params.video = fileId;
        }
      }
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
      if (response.video) {
        const hash = await getFileHash(params.video);
        await storage.set(hash, response.video.file_id);
      }
    }
  ],
  sendAnimation: [
    async (params, storage) => {
      if (isFile(params.animation)) {
        const file = await params.animation;
        const hash = await getFileHash(file);
        const fileId = await storage.get(hash);
        if (fileId) {
          params[MEDIA_CACHED] = file;
          params.animation = fileId;
        }
      }
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
      if (response.animation) {
        const hash = await getFileHash(params.animation);
        await storage.set(hash, response.animation.file_id);
      }
    }
  ],
  sendVoice: [
    async (params, storage) => {
      if (isFile(params.voice)) {
        const file = await params.voice;
        const hash = await getFileHash(file);
        const fileId = await storage.get(hash);
        if (fileId) {
          params[MEDIA_CACHED] = file;
          params.voice = fileId;
        }
      }
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
      if (response.voice) {
        const hash = await getFileHash(params.voice);
        await storage.set(hash, response.voice.file_id);
      }
    }
  ],
  sendVideoNote: [
    async (params, storage) => {
      if (isFile(params.video_note)) {
        const file = await params.video_note;
        const hash = await getFileHash(file);
        const fileId = await storage.get(hash);
        if (fileId) {
          params[MEDIA_CACHED] = file;
          params.video_note = fileId;
        }
      }
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
      if (response.video_note) {
        const hash = await getFileHash(params.video_note);
        await storage.set(hash, response.video_note.file_id);
      }
    }
  ],
  sendPaidMedia: [
    async (params, storage) => {
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
    }
  ],
  sendMediaGroup: [
    async (params, storage) => {
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
    }
  ],
  sendPoll: [
    async (params, storage) => {
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
    }
  ],
  editMessageMedia: [
    async (params, storage) => {
      if ("media" in params.media && isFile(params.media.media)) {
        const file = await params.media.media;
        const hash = await getFileHash(file);
        const fileId = await storage.get(hash);
        if (fileId) {
          params[MEDIA_CACHED] = file;
          params.media.media = fileId;
        }
      }
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
      const fileKey = response[params.media.type];
      if (fileKey) {
        const hash = await getFileHash(params.media.media);
        await storage.set(
          hash,
          Array.isArray(fileKey) ? fileKey.at(-1)?.file_id : fileKey?.file_id
        );
      }
    }
  ],
  sendSticker: [
    async (params, storage) => {
      if (isFile(params.sticker)) {
        const file = await params.sticker;
        const hash = await getFileHash(file);
        const fileId = await storage.get(hash);
        if (fileId) {
          params[MEDIA_CACHED] = file;
          params.sticker = fileId;
        }
      }
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
      if (response.sticker) {
        const hash = await getFileHash(params.sticker);
        await storage.set(hash, response.sticker.file_id);
      }
    }
  ],
  uploadStickerFile: [
    async (params, storage) => {
      if (isFile(params.sticker)) {
        const file = await params.sticker;
        const hash = await getFileHash(file);
        const fileId = await storage.get(hash);
        if (fileId) {
          params[MEDIA_CACHED] = file;
          params.sticker = fileId;
        }
      }
      return params;
    },
    async (response, params, storage) => {
      if (typeof response !== "object" || !params[MEDIA_CACHED]) return;
      const hash = await getFileHash(params[MEDIA_CACHED]);
      await storage.set(hash, response.file_id);
    }
  ]
};

const methods = Object.keys(MEDIA_HELPERS);
function mediaCache(options = {}) {
  const storage$1 = options.storage ?? storage.inMemoryStorage();
  return new gramio.Plugin("@gramio/media-cacher").preRequest(methods, async (context) => {
    const [preRequest] = MEDIA_HELPERS[context.method];
    context.params = await preRequest(context.params, storage$1);
    return context;
  }).group(
    (bot) => bot.onResponse(methods, async ({ method, params, response }) => {
      if (!params?.[MEDIA_CACHED]) {
        const [_, onResponse] = MEDIA_HELPERS[method];
        await onResponse(response, params, storage$1);
      }
    })
  );
}

exports.mediaCache = mediaCache;
